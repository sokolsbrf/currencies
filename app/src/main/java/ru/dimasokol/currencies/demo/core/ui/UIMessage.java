package ru.dimasokol.currencies.demo.core.ui;

import android.support.annotation.Nullable;
import android.text.TextUtils;

import java.io.Serializable;

/**
 * <p>Сообщение пользователю, предполагаемое конечное назначение которого — быть показанным где-то
 * в UI. При этом <em>«где-то»</em> вовсе не обязано быть диалоговым окном, но скорее всего это
 * будет самый типовый сценарий.</p>
 *
 * @author sokol
 */
public class UIMessage implements Serializable {

    /**
     * Серьёзность сообщения, согласно которой UI должен по-разному его отобразить.
     */
    public enum Severity {
        /**
         * Подсказка; возможно, в некоторых ситуациях не должна быть показана
         */
        Hint,
        /**
         * Предупреждение; не ошибка, но скорее всего отображение будет похоже
         */
        Warning,
        /**
         * Ошибка; вероятно, будет отображена в диалоге и т.п.
         */
        Error,
        /**
         * Фатальная ошибка; нечто непоправимое, на что UI должен отозваться радикально, например
         * даже всё закрыть и самоуничтожиться.
         */
        Fatal
    }

    private final Severity mSeverity;
    private final String mMessage;
    private String mTag;
    private boolean mConsidered = false;

    /**
     * Создание нового экземпляра сообщения с указанием серьёзности и текста
     * @param severity Серьёзность сообщения
     * @param message Текст сообщения
     */
    public UIMessage(Severity severity, String message) {
        mSeverity = severity;
        mMessage = message;
    }

    /**
     * Возвращает уровень серьёзности сообщения
     * @see Severity
     */
    public Severity getSeverity() {
        return mSeverity;
    }

    /**
     * Возвращает сам текст сообщения
     */
    public String getMessage() {
        return mMessage;
    }

    /**
     * <p>Возвращает тег сообщения.</p>
     * <p>Тег может использоваться для указания принадлежности сообщения какому-либо логическому
     * элементу, <strong>возможно</strong> отражённому в UI. Например, здесь может содержаться
     * имя поля в запросе, к которому относится ошибка; UI может обработать это как подпись
     * именно под нужным полем.</p>
     * @return Тег или {@code null}. Никогда не вернёт пустую строку, т.е. {@code getTag() != null}
     * является достаточной проверкой.
     */
    @Nullable
    public String getTag() {
        return mTag;
    }

    /**
     * Устанавливает тег
     * @param tag Тег, {@code null} для сброса.
     * @see #getTag()
     */
    public void setTag(String tag) {
        // Отсечём пустые строки
        if (TextUtils.isEmpty(tag))
            mTag = null;

        mTag = tag;
    }

    /**
     * Возвращает признак того, что данное сообщение уже учтено где-то в UI.
     * @return {@code true} если сообщение учтено (т.е., иными словами, отображено, принято к
     * сведению и более не нужно)
     */
    public boolean isConsidered() {
        return mConsidered;
    }

    /**
     * <p>Помечает сообщение как <strong>учтённое</strong>.</p>
     * <p>Сообщение считается учтённым когда оно уже отображено в UI и в дальнейшем нужно
     * предотвратить его всплытие где-либо. Типичный пример: сообщение отображалось в виде диалога
     * и пользователь его уже закрыл. Если при повороте экрана этот диалог всплывёт снова (потому
     * что выстрелит лоадер и будут показаны все ошибки), то получится нехорошо. Постоянно
     * воскресающие ошибки никого не порадуют.</p>
     * <p>С другой стороны, сообщение может требовать отображения сколь угодно долго, а потому никогда
     * не помечаться учтённым (например, если по логике UI оно отображается где-нибудь в виде
     * подписи).</p>
     */
    public void markAsConsidered() {
        mConsidered = true;
    }
}
